---
title: "Curtin CTF 2024"
categories:
  - CTF
  - Local
tags:
- Warmup
- Crypto
- Forensic
- Misc
- Reverse Engineering
- Osint
- Web
---

{% capture team %}
**Team:** Flag/junkie
* Ajiqqos
* SpicyMochi
{% endcapture %}

<div class="notice">{{ team | markdownify }}</div>

---

# WarmUp

---

### RE warmup
**Description:**<br>
Name the register that manages the current stack in 64-bit architectures called the stack pointer?

**Flag:**
CURTIN_CTF{RSP}

---

### Extentions
**Description:**<br>
Here is a basic challenge to learn the basics of digital forensics. Find the hidden flag.

**Flag:**
CURTIN_CTF{FLAG-EXTR4CTED_MiSS1ON_ACC0MLISHED}

Got password and zip password protected file. Read the content of the password and use it to unlock the zipfile
```bash
$ cat password
safepassword
$ unzip flag.zip
$ cat flag
Q1VSVElOX0NURntGTEFHX0VYVFI0Q1RFRF0NaVNTMU9OX0FDQzBNUExJU0hFRU0=
$ echo "Q1VSVElOX0NURntGTEFHX0VYVFI0Q1RFRF0NaVNTMU9OX0FDQzBNUExJU0hFRU0=" | base64 -d
CURTIN_CTF{FLAG-EXTR4CTED_MiSS1ON_ACC0MLISHED}
```
---

### Misc 1
**Description:**<br>
SSH as `ubuntu` and find the flag
`18.142.44.244`

**Flag:**
CURTIN_CTF{H1dd3n_f1l3}

Change the permission for the private key file to 600. We set private ssh keys to 600 so only the user who owns them can read them. If not the key will become unusable.
```bash
$ chmod 600 ./misc_1
$ ssh -i ./misc_1 ubuntu@18.142.44.244 -v
```

Using basic linux to navigate through the ssh and search for flag.
<img src="/assets/images/curtin24/misc1.png" alt="">

---

### Warmup-pwn
**Description:**<br>
Get to the win function to read the flag.
The admin will share the flag with you

**Flag:**
CURTIN_CTF{Cyb3rW4rri0rPr0t3ctTh3N3tw0rk}

Here I used gdb to list the disassemble for the main. Search for win() and copy the address. Put the address to the input prompt when running the file.
<img src="/assets/images/curtin24/warmuppwn1.png" alt="">

<img src="/assets/images/curtin24/warmuppwn2.png" alt="">

---

### Trivial 1
**Description:**<br>
With a primer, ignite the light.
Illuminate paths hidden **from sight**

**Flag:**
CURTIN_CTF{h4v3_y0us33n_op71mu5_pr1m3}

1.	Brute force using all primes and 1 to 100.
2.	Find the correct flag.

```python
def decrypt(encrypted_values, primes, key):
    decrypted_flag = ""

    for encrypted_val in encrypted_values:
        decrypted_char = encrypted_val

        for prime in reversed(primes):  # Reverse to undo the encryption
            decrypted_char = decrypted_char ^ key  # XOR to reverse the encryption
            decrypted_char = decrypted_char // prime  # Undo the multiplication

        # Convert the decrypted ASCII value to a character
        decrypted_flag += chr(decrypted_char)

    return decrypted_flag


# Given encrypted flag and primes
encrypted = [
    594210592671903223984670632285650038564805292576759304030567768941732090171624826090878166285636274764932736516132,
    9782102256911581663593927728229371984020525968926396146037520923635742496332172475457990676736787299620720321647151,
    024053702609710508 ...
]

primes = [
    762753748873595947897746019956536225138723924253002081166156597132862575903519447432353535160961397679225119554347,
    7928821605804498759626725447745019911223,
    7630901919735971485107874022535885400118024201377113255467307582298154844614252650526624455816640914255475613512793,
    309028057627582647075919408894479312597,
    9292867758193943774009686435866716211049467843773708273742385118963781425136723196802442961712715440041175728902151,
    348400890352831854127682446924981829751,
    12088786452523129715080041448548059948503851995099993438391085104663531562323539561705293163598347937919690971397638,
    5682440622785127910634313734938971232253,
    1069770744134110520388435758055727646592859579718385371154871200903293528792247699929337277895868206964814438658387,
    9514055739426604667390640798130006415264109693835449770569252227926038953229112542434022408433145025523574487578651,
    362284082898513297492061582443297976061,
    1332651195691078059494902004251147846249521360094681857443982730289573571702792833986477050685191162755841046346139,
    6680842587817251561044145599177810077297
]

# Brute-force all possible keys (from 1 to 100)
for key in range(1, 101):
    try:
        decrypted_flag = decrypt(encrypted, primes, key)
        print(f"Key: {key}, Decrypted flag: {decrypted_flag}")
    except Exception as e:
        continue  # If there's an error in decryption, skip to the next key
```

<img src="/assets/images/curtin24/trivial12.png" alt="">

---

# Crypto

---

### Trivial 2
**Description:**<br>
Do I need to solve a high-school math problem again?

**Flag:**
CURTIN_CTF{b4ck_70_r007s}

1.	The challenge encrypts a string using a simple polynomial-based transformation.
2.	From the formula of the encryption file, we can apply the reverse transformation to get the flag.

challenge.py:
```python
"""
Trivial 2
@author: ROxR10
"""

import numpy as np

def str_to_num_list(s):
    return [ord(c) for c in s]

def num_list_to_str(L):
    return ''.join([chr(n) for n in L])

def e_p(plain_text, coefficients):
    num_list = str_to_num_list(plain_text)
    encrypted_list = []

    for num in num_list:
        encrypted_value = sum(coefficients[i] * (num ** i) for i in range(len(coefficients)))
        encrypted_list.append(encrypted_value)

    return encrypted_list

def main():
    flag = "REDACTED"
    coefficients = [1, 0, 1]

    encrypted_list = e_p(flag, coefficients)

    print("Encrypted list:", encrypted_list)

if __name__ == "__main__":
    main()
```
```python
import math

# Encrypted list from the challenge
encrypted_list = [
    4490, 7226, 6725, 7057, 5330, 6085, 9026, 4490, 7057, 4901,
    15130, 9605, 2705, 9802, 11450, 9026, 3026, 2305, 9026,
    12997, 2305, 2305, 3026, 13226, 15626
]

def decrypt(encrypted_list):
    decrypted_chars = []

    for encrypted_value in encrypted_list:
        # Subtract 1 from the encrypted value
        adjusted_value = encrypted_value - 1

        # Take the square root to find the original ASCII value
        ascii_value = int(math.sqrt(adjusted_value))

        # Convert the ASCII value to the corresponding character
        decrypted_chars.append(chr(ascii_value))

    # Join the decrypted characters to form the final string (flag)
    return ''.join(decrypted_chars)

if __name__ == "__main__":
    decrypted_flag = decrypt(encrypted_list)
    print(f"Decrypted flag: {decrypted_flag}")
```

---

### Bluff
**Description:**<br>
No key, no flag. Get it?

**Flag:**
CURTIN_CTF{op3n_s3s4m3_7876598112}

This xor does not give keys, so I used the the flag format as a guild.

```python
def decrypt(enc_list, key):
    decrypted_chars = []
    key_len = len(key)

    for i, enc_val in enumerate(enc_list):
        chunk = i // key_len
        offset = i % key_len

        # Reverse the XOR operation and the chunk addition
        decrypted_char = (enc_val ^ key[offset]) - chunk
        decrypted_chars.append(chr(decrypted_char))

    return ''.join(decrypted_chars)


# The encrypted values from the challenge
enc_list = [
    66, 188, 199, 131, 75, 166, 245, 147, 87, 161, 232, 166,
    114, 223, 228, 181, 118, 222, 226, 239, 115, 209, 241,
    235, 63, 212, 169, 236, 65, 214, 173, 239, 59, 108
]

# The deduced key
key = [1, 233, 149, 215]

# Decrypt the message
decrypted_flag = decrypt(enc_list, key)
print("Decrypted flag:", decrypted_flag)
```

---

### RSA 1
**Description:**<br>
Sohan, the infamous crook, was finally caught and thrown into prison. There, he unexpectedly encounters Officer Kartik, who turns out to be his childhood friend.<br>
Kartik hands him a puzzle and says, "If you solve this, I promise I'll let you out.<br>
Help Sohan in his bid for freedom.

**Flag:**
CURTIN_CTF{1s_7h15_50m37h1ng_c10s3_70_m4g1c?}

Used chatGPT for this.
```python
import math

def find_primes(n, d):
    # Calculate q using the quadratic formula
    discriminant = d**2 + 4 * n
    if discriminant < 0:
        return None, None  # No real roots

    sqrt_disc = math.isqrt(discriminant)

    # Check if the discriminant is a perfect square
    if sqrt_disc * sqrt_disc != discriminant:
        return None, None  # Not a perfect square, no integer solutions

    # Calculate possible values for q
    q1 = (-d + sqrt_disc) // 2
    q2 = (-d - sqrt_disc) // 2

    # Calculate corresponding p values
    p1 = q1 + d
    p2 = q2 + d

    return (p1, q1), (p2, q2)

# Input values
n = int(input("Enter n (modulus): "))
d = int(input("Enter |p - q|: "))

# Find the prime factors
(prime1, prime2), (prime3, prime4) = find_primes(n, d)

if prime1 and prime2:
    print(f"Possible primes are p: {prime1}, q: {prime2}")
else:
    print("No valid prime pairs found.")

if prime3 and prime4:
    print(f"Possible primes are p: {prime3}, q: {prime4}")
else:
    print("No valid prime pairs found.")
```
```bash
$ Enter n (modulus):
1594088039308162219222397954641766845424 #fill all the input
```
```python
def decimal_to_utf8(decimal_number):
    # Convert decimal number to bytes using to_bytes method
    byte_representation = decimal_number.to_bytes((decimal_number.bit_length() + 7) // 8, 'big')

    # Decode bytes using UTF-8
    utf8_string = byte_representation.decode('utf-8')

    return utf8_string

# Example
original_decimal = 617715206715350827566805481320272314940016426736675843232202439786681438840440635475182629359482051519266685
print("Original Decimal:", original_decimal)

# Convert decimal to UTF-8 string
utf8_result = decimal_to_utf8(original_decimal)
print("Decimal to UTF-8 String:", utf8_result)
```
```bash
$ Original Decimal: 617715206715350827566805481320272314940016426736675843232202439786681438840440635475182629359482051519266685
Decimal to UTF-8 String: CURTIN_CTF{1s_7h15_50m37h1ng_c10s3_70_m4g1c?}
```

---

### Amalgam
**Description:**<br>
Rigid, yet brittle...<br>
NOTE: Enclose the flag within CURTIN_CTF{}

**Flag:**
CURTIN_CTF{dlP_50lv3d:)}

1.	Calculate the private key x by solving the discrete logarithm: h=gxmod  ph=gxmodp.
2.	Compute the shared secret s as s=c1xmod  ps=c1xmodp.
3.	Find the modular inverse of s, denoted as s_inv.
4.	Decrypt the message by computing m=(c2×sinv)mod  pm=(c2×sinv)modp.
5.	Convert the decrypted integer m to a byte string and decode to retrieve the original message or flag.

```python
from sympy.ntheory import discrete_log
from Crypto.Util.number import inverse, long_to_bytes

# Given paramaters
p = 186506814954895414068796533711441426871
g = 2
h = 128780011407215156870232600336696679553
c1 = 156581689710555992734938659724336258165
c2 = 113787733820173627914147318932861607685

#step 1: Compute the private key x
print("Computing the private key...")
x = discretet_log(p, h, g)
print(f"Private key x = {x}")

#step 2: Compute the shared secret s
s = pow(c1, x, p)

#step 3: Compute the modular inverse of s
s_inv = inverse(s, p)

#step 4: Recover the plaintext message m
m = (c2 * s_inv) % p

#step 5: Convert m to bytes
flag = long_to_bytes(m)

print(f"Recovered Flag: {flag.decode()}")
```
```bash
$ python3 factor.py
Computing the private key x...
Private key x = 63277427936816332851542320439881245850
Recovered Flag: dlP_50lv3d:)
```

---

### Dance of the Stream
**Description:**<br>
Row, row, row your boat, gently down the stream...

**Flag:**
CURTIN_CTF{g0_s0lv3_7h3_57r34m_pr0bl3m_0f_1r0d0v_n0w}

1.	Perform quarter-round transformations (q_r) on state values using bitwise operations (addition, XOR, shifts) to update them.
2.	Initialize the stream cipher state with a key, nonce, and counter, then copy the state into a working state for transformations.
3.	Apply 20 rounds of quarter-round operations (2 per loop) on the working state using the q_r function.
4.	After the rounds, combine the working state with the original state and pack the result into a byte stream.
5.	Use the stream_e function to generate a keystream based on the key and nonce, then XOR the keystream with the message to encrypt or decrypt.
6.	The o_value function XORs the input with the string b'leomessi' to obfuscate or de-obfuscate values like the nonce.
7.	The recover_nonce function reads an obfuscated nonce from a file, uses o_value to recover the original nonce, and converts it to an integer.
8.	The load_ciphertext function reads the ciphertext from a file.
9.	In decrypt_ciphertext, perform a brute-force search over 16-bit keys, generating keystreams for each key, XOR-ing with the ciphertext, and checking if the result is valid printable ASCII.
10.	If a valid decryption is found, the key and plaintext are returned; otherwise, the brute-force continues.
11.	In the main function, load the nonce and ciphertext, and attempt decryption by calling decrypt_ciphertext.


```python
import struct
from tqdm import tqdm

def q_r(a, b, c, d):
a = (a + b) & 0xFFFFFFFF
d = (d ^ a) << 16 | (d ^ a) >> (32 - 16)
c = (c + d) & 0xFFFFFFFF
b = (b ^ c) << 12 | (b ^ c) >> (32 - 12)
a = (a + b) & 0xFFFFFFFF
d = (d ^ a) << 8 | (d ^ a) >> (32 - 8)
c = (c + d) & 0xFFFFFFFF
b = (b ^ c) << 7 | (b ^ c) >> (32 - 7)
return a, b, c, d

def stream(key, nonce, counter):
state = [0] * 16
state[0] = 0x61707865
state[1] = 0x3320646e
state[2] = 0x79622d32
state[3] = 0x6b206574
state[4:6] = struct.unpack("<2L", key + b'\x00' * 6)
state[6:8] = [0] * 2
state[8:12] = [0] * 4
state[12] = counter
state[13] = nonce & 0xFFFFFFFF
state[14] = (nonce >> 32) & 0xFFFFFFFF
state[15] = 0

working_state = state[:]
for _ in range(20 // 2):
working_state[0], working_state[4], working_state[8], working_state[12] = q_r(
working_state[0], working_state[4], working_state[8], working_state[12]
)
working_state[1], working_state[5], working_state[9], working_state[13] = q_r(
working_state[1], working_state[5], working_state[9], working_state[13]
)
working_state[2], working_state[6], working_state[10], working_state[14] = q_r(
working_state[2], working_state[6], working_state[10], working_state[14]
)
working_state[3], working_state[7], working_state[11], working_state[15] = q_r(
working_state[3], working_state[7], working_state[11], working_state[15]
)
working_state[0], working_state[5], working_state[10], working_state[15] = q_r(
working_state[0], working_state[5], working_state[10], working_state[15]
)
working_state[1], working_state[6], working_state[11], working_state[12] = q_r(
working_state[1], working_state[6], working_state[11], working_state[12]
)
working_state[2], working_state[7], working_state[8], working_state[13] = q_r(
working_state[2], working_state[7], working_state[8], working_state[13]
)
working_state[3], working_state[4], working_state[9], working_state[14] = q_r(
working_state[3], working_state[4], working_state[9], working_state[14]
)

output = bytearray()
for i in range(16):
output.extend(struct.pack("<L", (working_state[i] + state[i]) & 0xFFFFFFFF))
return output

def stream_e(key, nonce, message):
keystream = bytearray()
for i in range(0, len(message), 64):
keystream.extend(stream(key, nonce, i // 64))
return bytes([m ^ k for m, k in zip(message, keystream)])

def o_value(value):
o_kie = b'leomessi'
return bytes([b ^ o_kie[i % len(o_kie)] for i, b in enumerate(value)])

def recover_nonce(o_nonce_path):
with open(o_nonce_path, 'rb') as f:
o_nonce = f.read()
nonce_bytes = o_value(o_nonce)
nonce = struct.unpack("<Q", nonce_bytes)[0]
return nonce

def load_ciphertext(ciphertext_path):
with open(ciphertext_path, 'rb') as f:
ciphertext = f.read()
return ciphertext

def decrypt_ciphertext(ciphertext, nonce):
print("Starting brute-force key search...")
for key_int in tqdm(range(0x0000, 0x10000)):
key = key_int.to_bytes(2, byteorder='big')
decrypted_message = stream_e(key, nonce, ciphertext)
try:
plaintext = decrypted_message.decode('utf-8')
if all(32 <= ord(c) <= 126 for c in plaintext):  # Check for printable ASCII
print(f"\nKey found: {key.hex()}")
print(f"Decrypted message: {plaintext}")
return key_int, plaintext
except UnicodeDecodeError:
continue
print("No valid plaintext found with the keys tried.")
return None, None

def main():
nonce = recover_nonce('o_nonce.txt')
ciphertext = load_ciphertext('ciphertext.txt')
key_int, plaintext = decrypt_ciphertext(ciphertext, nonce)
if key_int is not None:
print("\nSuccessful decryption:")
print(f"Key: {key_int:04x}")
print(f"Plaintext: {plaintext}")
else:
print("Decryption unsuccessful.")

if __name__ == '__main__':
main()

```

---

### Feel the Heat
**Description:**<br>
My friend asks "When am I ever going to use partial diffentiation in my life?"

**Flag:**
CURTIN_CTF{con57r41n3d_0p71m1z4710n}

**Approach:**<br>
For the key:
1.	Decrypt decrypted_key to get original_key_padded.
2.	Remove padding with unpad and print original_key, handling errors with a try-except block to catch decryption or padding failures.

For the flag:
1.	Set up the PDE function pde, used both during encryption and decryption.
2.	Define t_backward, the time array for solving the PDE in reverse.
3.	Use odeint to solve the PDE backward in time, with the key as the diffusion coefficient, recovering the original message state.
4.	Extract the recovered message at time zero (original state) from the solution.

Convert the numerical values back to characters by rounding them to the nearest ASCII values, then join them to form the original message.
```python
from Crypto.Cipher import DES
from Crypto.Util.Padding import unpad

# Reversed key from the bitwise operation
decrypted_key = b'R\x16r\xf7\x9c?"\xbb\xa5j\x91\xa0l\x16\xe5\x8d\xb0\x06\xdeW\x19\xb7mx'

# The key used for DES encryption
k = b'XOXOXOXO'

# Create a DES cipher object with ECB mode
cipher = DES.new(k, DES.MODE_ECB)

# Decrypt the reversed key
original_key_padded = cipher.decrypt(decrypted_key)

# Unpad the decrypted key to remove any padding that was added during encryption
try:
    original_key = unpad(original_key_padded, DES.block_size)
    print("Original Key:", original_key)
except ValueError:
    print("Decryption failed or padding is incorrect.")

```
```bash
$ python3 f.py
Original Key: b'2.77987109890597'
```
Solving using PDE backwards in time.
```python
import numpy as np
from scipy.integrate import odeint

# Load the encrypted message from the .npy file
encrypted_message = np.load('encrypted.npy')

# The floating-point key that was decrypted earlier
key = 2.77987109890597

# Number of points used in the encryption
num_points = len(encrypted_message)

# Define the PDE function (same as used in encryption)
def pde(u, t, D):
    return D * np.gradient(np.gradient(u))

# Time values used during encryption
t_max = 1.0
t_backward = np.linspace(t_max, 0, num_points)  # Time goes from t_max to 0 (backward in time)

# Solve the PDE backwards in time to reverse the encryption
recovered_solution = odeint(pde, encrypted_message, t_backward, args=(key,))

# Extract the first time step, which should correspond to the initial message
recovered_message = recovered_solution[-1]  # The last entry corresponds to time 0 (original state)

# Convert the numerical array back to characters (rounding to nearest ASCII values)
message_chars = [chr(int(round(c))) for c in recovered_message if 0 <= c < 128]

# Join the characters to form the original message
original_message = ''.join(message_chars)

print("Recovered Message:", original_message)
```
```bash
$ python3 e.py
Recovered Message: CURTIN_CTF{con57r41n3d_0p71m1z4710n}
```

---

### Tutto Bene
**Description:**<br>
Somebody call the fire brigade!

**Flag:**
CURTIN_CTF{n07h1n9_h4pp3n3d_7h3_cpu_s33m5_70_b3_f1n3}

1.	Generate all possible 2-character combinations of printable characters.
2.	Compute the SHA-512 hash for each pair and extract various substrings.
3.	Reverse these substrings and store them in a dictionary for quick lookup.
4.	Slide a window over the given hash h, extract substrings, reverse them, and check for matches in the dictionary.
5.	Collect all matching pairs and reconstruct the flag by sorting them based on their positions in h.

```python
import hashlib
import string

# The given h value (truncated for brevity in this example)
h = "8b1de8b2e359021a600fa563b32b3b15ab00d1b0855ad49c ... "

# Build the dictionary of possible hash substrings
printable_chars = ''.join([chr(c) for c in range(32, 127)])
pairs = [a + b for a in printable_chars for b in printable_chars]

s_rev_candidate_dict = {}
for pair in pairs:
    hash_value = hashlib.sha512(pair.encode('utf-8')).hexdigest()
    for a in range(1, 17):
        for b in range(1, 17):
            k = a + b
            if 2 <= k <= 32:
                L = 128 - k
                s_rev_candidate = hash_value[a:-b]
                s_rev_candidate_dict[s_rev_candidate] = pair

# Extract substrings from h and attempt to find matches
flag_pairs = []
for i in range(len(h) - 96):
    for L in range(96, 127):
        if i + L <= len(h):
            s = h[i:i + L]
            s_rev = s[::-1]
            if s_rev in s_rev_candidate_dict:
                pair = s_rev_candidate_dict[s_rev]
                flag_pairs.append((i, pair))

# Sort pairs based on their position and reconstruct the flag
flag_pairs = sorted(set(flag_pairs), key=lambda x: x[0])
flag = ''.join([pair for _, pair in flag_pairs])

print("Recovered flag:", flag)
```

The output was not 100% accurate, so I manually adjusted to get the correct flag.

<img src="/assets/images/curtin24/tuttobene.png" alt="">

