---
title: "Curtin CTF 2024"
categories:
  - CTF
  - Local
tags:
- Warmup
- Crypto
- Forensic
- Misc
- Reverse Engineering
- Osint
- Web
---

{% capture team %}
**Team:** Flag/junkie
* Ajiqqos
* SpicyMochi
{% endcapture %}

<div class="notice">{{ team | markdownify }}</div>

---

# WarmUp

---

### RE warmup
**Description:**<br>
Name the register that manages the current stack in 64-bit architectures called the stack pointer?

**Flag:**
CURTIN_CTF{RSP}

---

### Extentions
**Description:**<br>
Here is a basic challenge to learn the basics of digital forensics. Find the hidden flag.

**Flag:**
CURTIN_CTF{FLAG-EXTR4CTED_MiSS1ON_ACC0MLISHED}

Got password and zip password protected file. Read the content of the password and use it to unlock the zipfile
```bash
$ cat password
safepassword
$ unzip flag.zip
$ cat flag
Q1VSVElOX0NURntGTEFHX0VYVFI0Q1RFRF0NaVNTMU9OX0FDQzBNUExJU0hFRU0=
$ echo "Q1VSVElOX0NURntGTEFHX0VYVFI0Q1RFRF0NaVNTMU9OX0FDQzBNUExJU0hFRU0=" | base64 -d
CURTIN_CTF{FLAG-EXTR4CTED_MiSS1ON_ACC0MLISHED}
```
---

### Misc 1
**Description:**<br>
SSH as `ubuntu` and find the flag
`18.142.44.244`

**Flag:**
CURTIN_CTF{H1dd3n_f1l3}

Change the permission for the private key file to 600. We set private ssh keys to 600 so only the user who owns them can read them. If not the key will become unusable.
```bash
$ chmod 600 ./misc_1
$ ssh -i ./misc_1 ubuntu@18.142.44.244 -v
```

Using basic linux to navigate through the ssh and search for flag.
<img src="/assets/images/curtin24/misc1.png" alt="">

---

### Warmup-pwn
**Description:**<br>
Get to the win function to read the flag.
The admin will share the flag with you

**Flag:**
CURTIN_CTF{Cyb3rW4rri0rPr0t3ctTh3N3tw0rk}

Here I used gdb to list the disassemble for the main. Search for win() and copy the address. Put the address to the input prompt when running the file.
<img src="/assets/images/curtin24/warmuppwn1.png" alt=""><br>
<img src="/assets/images/curtin24/warmuppwn2.png" alt="">

---

### Trivial 1
**Description:**<br>
With a primer, ignite the light.
Illuminate paths hidden **from sight**

**Flag:**
CURTIN_CTF{h4v3_y0us33n_op71mu5_pr1m3}

1.	Brute force using all primes and 1 to 100.
2.	Find the correct flag.

<img src="/assets/images/curtin24/trivial11.png" alt=""><br>
<img src="/assets/images/curtin24/trivial12.png" alt="">

---

# Crypto

---

### Trivial 2
**Description:**<br>
Do I need to solve a high-school math problem again?

**Flag:**
CURTIN_CTF{b4ck_70_r007s}

1.	The challenge encrypts a string using a simple polynomial-based transformation.
2.	From the formula of the encryption file, we can apply the reverse transformation to get the flag.

<img src="/assets/images/curtin24/trivial21.png" alt=""><br>
<img src="/assets/images/curtin24/trivial22.png" alt="">

---

### Bluff
**Description:**<br>
No key, no flag. Get it?

**Flag:**
CURTIN_CTF{op3n_s3s4m3_7876598112}

This xor does not give keys, so I used the the flag format as a guild.

<img src="/assets/images/curtin24/bluff.png" alt="">

---

### RSA 1
**Description:**<br>
Sohan, the infamous crook, was finally caught and thrown into prison. There, he unexpectedly encounters Officer Kartik, who turns out to be his childhood friend.
Kartik hands him a puzzle and says, "If you solve this, I promise I'll let you out.
Help Sohan in his bid for freedom.

**Flag:**
CURTIN_CTF{1s_7h15_50m37h1ng_c10s3_70_m4g1c?}

Used chatGPT for this.
```python
import math

def find_primes(n, d):
    # Calculate q using the quadratic formula
    discriminant = d**2 + 4 * n
    if discriminant < 0:
        return None, None  # No real roots

    sqrt_disc = math.isqrt(discriminant)

    # Check if the discriminant is a perfect square
    if sqrt_disc * sqrt_disc != discriminant:
        return None, None  # Not a perfect square, no integer solutions

    # Calculate possible values for q
    q1 = (-d + sqrt_disc) // 2
    q2 = (-d - sqrt_disc) // 2

    # Calculate corresponding p values
    p1 = q1 + d
    p2 = q2 + d

    return (p1, q1), (p2, q2)

# Input values
n = int(input("Enter n (modulus): "))
d = int(input("Enter |p - q|: "))

# Find the prime factors
(prime1, prime2), (prime3, prime4) = find_primes(n, d)

if prime1 and prime2:
    print(f"Possible primes are p: {prime1}, q: {prime2}")
else:
    print("No valid prime pairs found.")

if prime3 and prime4:
    print(f"Possible primes are p: {prime3}, q: {prime4}")
else:
    print("No valid prime pairs found.")
```
```bash
$ Enter n (modulus):
1594088039308162219222397954641766845424 #fill all the input
```
```python
def decimal_to_utf8(decimal_number):
    # Convert decimal number to bytes using to_bytes method
    byte_representation = decimal_number.to_bytes((decimal_number.bit_length() + 7) // 8, 'big')

    # Decode bytes using UTF-8
    utf8_string = byte_representation.decode('utf-8')

    return utf8_string

# Example
original_decimal = 617715206715350827566805481320272314940016426736675843232202439786681438840440635475182629359482051519266685
print("Original Decimal:", original_decimal)

# Convert decimal to UTF-8 string
utf8_result = decimal_to_utf8(original_decimal)
print("Decimal to UTF-8 String:", utf8_result)
```
```bash
$ Original Decimal: 617715206715350827566805481320272314940016426736675843232202439786681438840440635475182629359482051519266685
Decimal to UTF-8 String: CURTIN_CTF{1s_7h15_50m37h1ng_c10s3_70_m4g1c?}
```

---

### Amalgam
**Description:**<br>
Rigid, yet brittle...
NOTE: Enclose the flag within CURTIN_CTF{}

**Flag:**
CURTIN_CTF{dlP_50lv3d:)}

1.	Calculate the private key x by solving the discrete logarithm: h=gxmod  ph=gxmodp.
2.	Compute the shared secret s as s=c1xmod  ps=c1xmodp.
3.	Find the modular inverse of s, denoted as s_inv.
4.	Decrypt the message by computing m=(c2×sinv)mod  pm=(c2×sinv)modp.
5.	Convert the decrypted integer m to a byte string and decode to retrieve the original message or flag.

```python
from sympy.ntheory import discrete_log
from Crypto.Util.number import inverse, long_to_bytes

# Given paramaters
p = 186506814954895414068796533711441426871
g = 2
h = 128780011407215156870232600336696679553
c1 = 156581689710555992734938659724336258165
c2 = 113787733820173627914147318932861607685

#step 1: Compute the private key x
print("Computing the private key...")
x = discretet_log(p, h, g)
print(f"Private key x = {x}")

#step 2: Compute the shared secret s
s = pow(c1, x, p)

#step 3: Compute the modular inverse of s
s_inv = inverse(s, p)

#step 4: Recover the plaintext message m
m = (c2 * s_inv) % p

#step 5: Convert m to bytes
flag = long_to_bytes(m)

print(f"Recovered Flag: {flag.decode()}")
```
```bash
$ python3 factor.py
Computing the private key x...
Private key x = 63277427936816332851542320439881245850
Recovered Flag: dlP_50lv3d:)
```

---

### Dance of the Stream
**Description:**<br>
Row, row, row your boat, gently down the stream...

**Flag:**
CURTIN_CTF{g0_s0lv3_7h3_57r34m_pr0bl3m_0f_1r0d0v_n0w}

1.	Perform quarter-round transformations (q_r) on state values using bitwise operations (addition, XOR, shifts) to update them.
2.	Initialize the stream cipher state with a key, nonce, and counter, then copy the state into a working state for transformations.
3.	Apply 20 rounds of quarter-round operations (2 per loop) on the working state using the q_r function.
4.	After the rounds, combine the working state with the original state and pack the result into a byte stream.
5.	Use the stream_e function to generate a keystream based on the key and nonce, then XOR the keystream with the message to encrypt or decrypt.
6.	The o_value function XORs the input with the string b'leomessi' to obfuscate or de-obfuscate values like the nonce.
7.	The recover_nonce function reads an obfuscated nonce from a file, uses o_value to recover the original nonce, and converts it to an integer.
8.	The load_ciphertext function reads the ciphertext from a file.
9.	In decrypt_ciphertext, perform a brute-force search over 16-bit keys, generating keystreams for each key, XOR-ing with the ciphertext, and checking if the result is valid printable ASCII.
10.	If a valid decryption is found, the key and plaintext are returned; otherwise, the brute-force continues.
11.	In the main function, load the nonce and ciphertext, and attempt decryption by calling decrypt_ciphertext.


```python
import struct
from tqdm import tqdm

def q_r(a, b, c, d):
a = (a + b) & 0xFFFFFFFF
d = (d ^ a) << 16 | (d ^ a) >> (32 - 16)
c = (c + d) & 0xFFFFFFFF
b = (b ^ c) << 12 | (b ^ c) >> (32 - 12)
a = (a + b) & 0xFFFFFFFF
d = (d ^ a) << 8 | (d ^ a) >> (32 - 8)
c = (c + d) & 0xFFFFFFFF
b = (b ^ c) << 7 | (b ^ c) >> (32 - 7)
return a, b, c, d

def stream(key, nonce, counter):
state = [0] * 16
state[0] = 0x61707865
state[1] = 0x3320646e
state[2] = 0x79622d32
state[3] = 0x6b206574
state[4:6] = struct.unpack("<2L", key + b'\x00' * 6)
state[6:8] = [0] * 2
state[8:12] = [0] * 4
state[12] = counter
state[13] = nonce & 0xFFFFFFFF
state[14] = (nonce >> 32) & 0xFFFFFFFF
state[15] = 0

working_state = state[:]
for _ in range(20 // 2):
working_state[0], working_state[4], working_state[8], working_state[12] = q_r(
working_state[0], working_state[4], working_state[8], working_state[12]
)
working_state[1], working_state[5], working_state[9], working_state[13] = q_r(
working_state[1], working_state[5], working_state[9], working_state[13]
)
working_state[2], working_state[6], working_state[10], working_state[14] = q_r(
working_state[2], working_state[6], working_state[10], working_state[14]
)
working_state[3], working_state[7], working_state[11], working_state[15] = q_r(
working_state[3], working_state[7], working_state[11], working_state[15]
)
working_state[0], working_state[5], working_state[10], working_state[15] = q_r(
working_state[0], working_state[5], working_state[10], working_state[15]
)
working_state[1], working_state[6], working_state[11], working_state[12] = q_r(
working_state[1], working_state[6], working_state[11], working_state[12]
)
working_state[2], working_state[7], working_state[8], working_state[13] = q_r(
working_state[2], working_state[7], working_state[8], working_state[13]
)
working_state[3], working_state[4], working_state[9], working_state[14] = q_r(
working_state[3], working_state[4], working_state[9], working_state[14]
)

output = bytearray()
for i in range(16):
output.extend(struct.pack("<L", (working_state[i] + state[i]) & 0xFFFFFFFF))
return output

def stream_e(key, nonce, message):
keystream = bytearray()
for i in range(0, len(message), 64):
keystream.extend(stream(key, nonce, i // 64))
return bytes([m ^ k for m, k in zip(message, keystream)])

def o_value(value):
o_kie = b'leomessi'
return bytes([b ^ o_kie[i % len(o_kie)] for i, b in enumerate(value)])

def recover_nonce(o_nonce_path):
with open(o_nonce_path, 'rb') as f:
o_nonce = f.read()
nonce_bytes = o_value(o_nonce)
nonce = struct.unpack("<Q", nonce_bytes)[0]
return nonce

def load_ciphertext(ciphertext_path):
with open(ciphertext_path, 'rb') as f:
ciphertext = f.read()
return ciphertext

def decrypt_ciphertext(ciphertext, nonce):
print("Starting brute-force key search...")
for key_int in tqdm(range(0x0000, 0x10000)):
key = key_int.to_bytes(2, byteorder='big')
decrypted_message = stream_e(key, nonce, ciphertext)
try:
plaintext = decrypted_message.decode('utf-8')
if all(32 <= ord(c) <= 126 for c in plaintext):  # Check for printable ASCII
print(f"\nKey found: {key.hex()}")
print(f"Decrypted message: {plaintext}")
return key_int, plaintext
except UnicodeDecodeError:
continue
print("No valid plaintext found with the keys tried.")
return None, None

def main():
nonce = recover_nonce('o_nonce.txt')
ciphertext = load_ciphertext('ciphertext.txt')
key_int, plaintext = decrypt_ciphertext(ciphertext, nonce)
if key_int is not None:
print("\nSuccessful decryption:")
print(f"Key: {key_int:04x}")
print(f"Plaintext: {plaintext}")
else:
print("Decryption unsuccessful.")

if __name__ == '__main__':
main()

```